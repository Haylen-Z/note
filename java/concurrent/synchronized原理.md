# synchronized原理

线程对对象加锁实际上是获取对象的**monitor**的所有权。

同步方法的字节码会有一个**ACC_SYNCHRONIZED**标志，告诉jvm这是一个同步方法。jvm执行同步方法时，线程需先持有**monitor**，方法返回时（不论正常返回还是有异常）会释放**monitor**。

同步代码块使用的是**MonitorEnter**和**MonitorExit**这两个字节码指令。执行**MonitorEnter**指令时，线程会尝试获取**monitor**的所有权，如果**monitor**未被别的线程持有或已被线程自己持有，就对锁计数器+1；执行MonitorExit指令时，对所计数器-1；当锁计数器为0时，锁就被释放了。如果获取monitor失败，线程或被阻塞，直到别的线程释放monitor。

**monitor**的实现时基于操作系统的**Mutex Lock**，这是一个重量级锁，加锁和释放锁的开销很大。Jdk1.6后，synchoronized被优化，加入了偏向锁、轻量级锁、自旋锁、锁消除和锁粗化等技术。

锁主要有四种状态，依次是：无锁、偏向锁、轻量级锁、重量级锁，随着锁的竞争的激烈和逐渐升级；锁只能被升级，而不能被降级。

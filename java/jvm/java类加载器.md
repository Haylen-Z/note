# java类加载器

类加载器用来把class文件加载到jvm中，转换成jvm运行时数据结构，生成class对象。

jvm内置了三个加载器，除了启动类加载器，其它类加载器都继承java.lang.ClassLoader：

- **BootstrapClassLoader（启动类加载器）**， 最顶层的类加载器，用于加载%JAVA_HOME%/lib下的jar包和类。
- **ExtensionClassLoader（扩展类加载器）**， 用于加载%JAVA_HOME%/lib/ext下的jar包和类。
- **AppClassLoader（应用类加载器）**， 用于加载应用的classpath下的jar包和类。

## 双亲委派模型

除了启动类加载器，其它类加载器都有一个父类加载器，父类加载器为null时，默认将启动类加载器作为父加载器。

                     +------------------------+
                     | BootstrapClassLoader   |
                     +------------+-----------+
                                  ^
                                  |
                                  |
                                  |
                     +------------+-----------+
                     | ExtensionClassLoader   |
                     +------------+-----------+
                                  ^
                                  |
                                  |
                     +------------+-----------+
                     | AppClassLoader         |
                     +------------+-----------+
                                  ^
                                  |
               +------------------+-------------+
               |                                |
    +----------+--------------+    +------------+----------+
    | UserDefinedClassLoader  |    | UserDefinedClassLoader|
    +-------------------------+    +-----------------------+

**当类加载器收到加载请求时，先检查类是否已被加载过，加载过了就直接返回，没加载过就执行类加载过程。类加载器会先把加载请求委派给父类加载器尝试加载，当父类加载器无法加载时，自己再尝试加载**。可见，所有类加载请求最后都会委派到启动类加载器。

使用双亲委派模型带来的好处：

- **避免类重复加载**。比如，相同的类文件被两个不同的类加载器加载，生成两个不同的类。
- **提高安全性**。如果有恶意用户创建了一个String类，功能与java自带的String相同，jvm加载了这个类，程序使用了这个类便会产生安全问题。如果使用双亲委派机制，启动类加载器会先加载java自带的String类，不会加载自定义的String类。
